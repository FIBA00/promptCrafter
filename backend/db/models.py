from sqlalchemy import Column, String, ForeignKey, TIMESTAMP, Boolean, Integer, Date
from sqlalchemy.orm import relationship
from sqlalchemy.sql.sqltypes import DateTime
from sqlalchemy.sql.expression import text
from sqlalchemy.sql import func
from sqlalchemy.ext.mutable import MutableList
from sqlalchemy.dialects.postgresql import ARRAY

from db.database import Base


class Prompts(Base):
    """should match this
    prompt_id: uuid.UUID
    title: str
    role: str
    task: str
    constraints: str
    output: str
    personality: str
    created_at: datetime
    tags: list[str] = []
    author: str
    """

    __tablename__ = "prompts"

    prompt_id = Column(String, primary_key=True, index=True)
    title = Column(String, index=True)
    role = Column(String, index=True)
    task = Column(String, index=True)
    constraints = Column(String)
    output = Column(String)
    personality = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    # Note: Using Postgres ARRAY for tags
    tags = Column(MutableList.as_mutable(ARRAY(String)), default=[])

    # Foreign Keys
    author_id = Column(String, ForeignKey("users.user_id"))

    # Relationships
    author = relationship("User", back_populates="prompts")
    structured_version = relationship(
        "StructuredPrompts", back_populates="original_prompt", uselist=False
    )


class User(Base):
    __tablename__ = "users"

    user_id = Column(String, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    password = Column(String, nullable=False)
    email = Column(String, unique=True, index=True)
    phone_number = Column(String, nullable=True)
    is_admin = Column(Boolean, nullable=False, server_default=text("false"))
    is_verified = Column(Boolean, nullable=False, server_default=text("false"))

    created_at = Column(
        TIMESTAMP(timezone=True), nullable=False, server_default=text("now()")
    )

    # Rate Limiting
    daily_token_limit = Column(Integer, nullable=False, server_default=text("10"))
    tokens_used_today = Column(Integer, nullable=False, server_default=text("0"))
    last_token_reset = Column(Date, nullable=True)

    # Relationships
    prompts = relationship("Prompts", back_populates="author")
    structured_prompts = relationship("StructuredPrompts", back_populates="author")


class StructuredPrompts(Base):
    __tablename__ = "structured_prompts"
    prompt_id = Column(String, primary_key=True, index=True)
    structured_prompt = Column(String)
    natural_prompt = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Foreign Keys
    author_id = Column(String, ForeignKey("users.user_id"))
    original_prompt_id = Column(String, ForeignKey("prompts.prompt_id"))

    # Relationships
    author = relationship("User", back_populates="structured_prompts")
    original_prompt = relationship("Prompts", back_populates="structured_version")


"""
EXAMPLE WORKFLOW & EXPLANATION
------------------------------

Here is how the database operations work for your "Prompt Refinement" scenario:

Scenario: 
A User (id="user_123") sends a raw prompt. You want to save that raw prompt, 
generate a structured version using AI, and then save the structured version linked to both.

# 1. Create the User (if they don't exist, just for context)
user = User(user_id="user_123", username="test_user", email="test@example.com")
db.add(user)
db.commit()

# 2. Receive & Save the Original Prompt
# We create the prompt row first. We need to do this to generate a specific 'prompt_id'.
original_prompt = Prompts(
    prompt_id="prompt_abc",  # usually generated by UUID
    title="Help me code",
    role="Coder",
    task="Write python",
    author_id=user.user_id   # LINK 1: Connects this prompt to the User
)
db.add(original_prompt)
db.commit() 
# Now 'original_prompt' is saved and has a confirmed place in the DB.

# 3. Generate Structured Prompt (The "AI" part)
# ... complex logic happens here ...
generated_text = "You are an expert Python coder..."

# 4. Save the Structured Prompt
# Now we create the structured prompt row. We rely on the IDs we have from previous steps.
structured_prompt = StructuredPrompts(
    prompt_id="struct_xyz",  # New ID for this specific row
    structured_prompt=generated_text,
    natural_prompt="The original natural language request...",
    
    author_id=user.user_id,                  # LINK 2: Connects to same User
    original_prompt_id=original_prompt.prompt_id  # LINK 3: Connects to the specific Prompt from Step 2
)
db.add(structured_prompt)
db.commit()

# 5. How to access this data later?

# A. Start from the User: "Show me all structured prompts by this user"
# user.structured_prompts  <-- returns a list of StructuredPrompts objects

# B. Start from the Original Prompt: "Show me the improved version of this prompt"
# original_prompt.structured_version <-- returns the single StructuredPrompts object

# C. Start from the Structured Prompt: "Who wrote the original request?"
# structured_prompt.original_prompt.author <-- returns the User object
"""
